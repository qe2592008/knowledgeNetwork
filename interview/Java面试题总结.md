### Java
##### 多个线程同时读写，读线程的数量远大于写线程，你认为应该如何解决并发的问题？你会选择加什么样的锁？
> 此时最好使用读写锁：ReentrantReadWriteLock。
>
> 该锁内部维护了两个锁，读锁与写锁，多个读线程可以同时持有读锁，而只有一个线程可以持有写锁，读锁被持有的情况下，只接受读线程，不接受写线程；写锁被持有的情况下，不接受任何线程，可见读锁是一个共享锁，写锁是一个独占锁，二者均是可重入的，且支持非公平与公平锁，默认为非公平锁。
##### JAVA的AQS是否了解，它是干嘛的？
> AQS是同步器，全称：`AbstractQueuedSynchronizer`，是并发包中用于实现Lock、Semaphore、CountDownLatch、CyclicBarrier等同步组件的基础。它内部通过维护一个int值来持有同步器的状态。同步器的实现类一般作为同步组件的内部类而存在。为同步组件的同步实现提供基础设施
>
> 同步器内部维护了一个同步队列，这个一个双向队列，主要用于存储那些获取锁失败的线程，同时每个同步器还能关联多个Condition组件，每个Condition内部维护了一个等待队列，这是一个单向队列，主要用于存储被condition.await挂起的线程，这些线程可以设置超时时间，当时间一到会自动苏醒，或者等待被其他线程手动唤醒，唤醒的线程会转移到同步队列，但是await的退出必然标志着这个线程再次获取到了锁，要不然被唤醒的线程会在同步队列中一致等待获取到锁。
##### 除了synchronized关键字之外，你是怎么来保障线程安全的？
> 保证线程安全的方式还是有很多的，有锁的方式与无锁的方式：
> - 有锁的方式就是synchronized内置锁和Lock显式锁
> - 无锁的方式就是CAS原子操作+无限循环来保证线程安全
> - 还有原子类可以保证一定的线程安全
> - 使用ThreadLocal
> - volatile
> - final
> - 使用并发集合：
    - ConcurrentHashMap
    - ConcurrentLinkedDeque
    - ConcurrentLinkedQueue
    - CopyOnWriteArrayList
    - CopyOnWriteArraySet
    - ConcurrentSkipLinkMap
    - ConcurrentSkipListSet
##### 什么时候需要加volatile关键字？它能保证线程安全吗？
> 线程安全的三大特性是可见性，原子性，有序性，而volatile只能保证有序性与可见性，无法保证原子性，所以只使用volatile是无法保证线程安全的，当然对于本身就是原子操作的变量来说只使用volatile倒是也能保证安全性，但是一般情况下针对变量的操作都不会是原子的，这时候就需要借助CAS操作来实现，当然也可以使用锁来实现，但是使用了锁之后，锁本身就会保证可见性和有序性，那么volatile就显得多余了，所有我们将其和只能保证原子性的功能整合在一起就行
##### 线程池内的线程如果全部忙，提交一个新的任务，会发生什么？队列全部塞满了之后，还是忙，再提交会发生什么？
> 线程池的原理：任务提交后，首先检查核心线程数是否够数，如果不够直接创建线程执行，如果核心线程够数那么就尝试将任务放置到阻塞队列，如果阻塞队列已满，那么检查总线程数时候够数，如果不够则创建新线程执行任务，否则走补偿策略。
##### Tomcat本身的参数你一般会怎么调整？
> Tomcat是一个java编写的Web容器，它本身也要运行于JVM中。所以一般Tomcat的调整分为两种一种是它依赖的JVM的调整，另一方面就是Tomcat自身的调整
>
> - JVM调整<br/>
> -Xms\<size\>：JVM初始化堆的大小<br/>
> -Xmx\<size\>：JVM堆的最大值，一般为可用内存的80%，堆的最大值设定一般需要根据实际的垃圾收集情况来进行调整，如果垃圾收集一次很慢（一次完全的垃圾收集应该不超过 3-5 秒），那么需要调小容量，如果垃圾收集很频繁，那么需要调大容量，且一般将初始大小与最大值调整为一样的值<br/>
> 位置：Windows下，在文件{tomcat_home}/bin/catalina.bat；Unix下，在文件{tomcat_home}/bin/catalina.sh
> 设置方法：set JAVA_OPTS='-Xms1000m –Xmx3000m'
> - 自身调整<br/>
> 
##### synchronized关键字锁住的是什么东西？在字节码中是怎么表示的？在内存中的对象上表现为什么？
> 对象；monitorenter和monitorexit；针对对象的对象头的操作
##### wait/notify/notifyAll方法需不需要被包含在synchronized块中？这是为什么？
> 这三个方法必须与synchronized配合使用，包含在临界区代码中，因为这三个方法是定义在Object中的，是针对具体对象而言的，而不是线程，wait等待也是指将持有这个对象锁的线程暂停，放到锁对象的等待队列，而notify和notifyAll方法也是这个锁对象来唤醒等待队列中的线程。
##### ExecutorService你一般是怎么用的？是每个service放一个还是一个项目里面放一个？有什么好处？
> 一般是一个项目放一个ExecutorService，如果一个Service放一个，那么将会导致项目中同时存在多个线程池，既不利于管理，也不利于查找问题，只定义一个便于统一管理，查找方便，空间利用率也会有所提升
### 框架
##### 你有没有用过Spring的AOP? 是用来干嘛的? 大概会怎么使用？
> 使用AOP实现了注解的功能，那是一个对请求参数进行初始化的注解。
> Spring中的很多功能也是借助于AOP实现的，比如事务注解@Transactional
##### 如果一个接口有2个不不同的实现, 那么怎么来Autowire一个指定的实现？
> 需要使用@Qualifier注解来指定要注入的实现的别名
##### Spring的声明式事务 @Transaction注解一般写在什么位置? 抛出了异常会自动回滚吗？有没有办法控制不触发回滚?
> 该注解一般标注在事务方法的之上，当然也可以标注到类上，标注到类上表示类中的所有public方法均需要使用事务，标注到方法上，仅表示该方法需要使用事务
>
> 默认情况下抛出不受检异常就会触发回滚，受检异常不会导致事务回滚，可以通过rollbackFor来设置哪些异常可以导致回滚，这些异常包括所有的受检和不受检异常，通过noRollbackFor来设置哪些异常不会导致事务回滚
##### 如果想在某个Bean生成并装配完毕后执行自己的逻辑，可以什么方式实现？
> 使用BeanPostProcessor来实现，实现该接口，它定义了两个方法，postProcessBeforeInitialization和postProcessAfterInitialization分别用于用户自定义初始化之前、之后执行的自定义逻辑，然后将其配置到配置文件中即可
##### SpringBoot没有放到web容器里为什么能跑HTTP服务？
> 因为SpringBoot在导入web包之后默认就导入了内置服务器的jar包，每个打包为jar格式的SpringBoot项目都是一个可执行程序，web容器被内置
##### SpringBoot中如果你想使用自定义的配置文件而不仅仅是application.properties，应该怎么弄？
> 自定义配置文件，然后在java文件中手动加载即可，可以使用注解的方式加载，很是方便
> 涉及到的注解包括：
> - @Value：获取已被加载的配置中的值项
> - @PropertySource：加载指定类路径下的自定义配置文件
> - @ConfigurationProperties：在将配置文件中的配置加载到内存并与JavaBean关联时，用于指定要使用的配置项前缀
> - @EnableConfigurationProperties：用于在使用关联配置的JavaBean时，指定JavaBean的类型
##### SpringMVC中RequestMapping可以指定GET, POST方法么？怎么指定？
> 完全可以啊
> ```java
> @RequestMapping(value = "/list", method = RequestMethod.GET)
> ```
##### SpringMVC如果希望把输出的Object(例如XXResult或者XXResponse)这种包装为JSON输出, 应该怎么处理?
> 添加注解@ResponseBody即可
##### 怎样拦截SpringMVC的异常，然后做自定义的处理理，比如打日志或者包装成JSON?
> 使用统一异常处理器注解：
> ```java
> @ExceptionHandler(XxxException.class)
> ```
> 再配合注解@ControllerAdvice实现异常的拦截与处理
### MySQL
##### 如果有很多数据插入MYSQL，你会选择什么方式?
> 批量插入方式
##### 如果查询很慢，你会想到的第一个方式是什么？索引是干嘛的?
> 查询慢，首先就是添加索引。
> 加快查询速度，索引是以一定的算法将数据缓存到内存中去
> 索引主要用于定位数据，在索引中一般会含有指向指定数据的指针，使用索引可以实现范围查找、定位查找等功能
##### 如果建了一个单列索引，查询的时候查出2列，会用到这个单列索引吗？
> 会
##### 如果建了一个包含多个列的索引，查询的时候只用了第一列，能不能用上这个索引？查三列呢？
> 可以，可以
##### 接上题，如果where条件后面带有一个 i + 5 < 100 会使用到这个索引吗？
> 不使用<br/>
> NOT IN 、<>、!=不使用索引，但<,<=，=，>,>=,BETWEEN,IN是可以用到索引的
##### 怎么看是否用到了某个索引？
> 跟踪查看SQL语句的"执行计划"就知道了，例如,mysql下可以用这样方式跟踪：explain SQL语句
##### like %aaa%会使用索引吗? like aaa%呢?
> like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。
#####  drop、truncate、delete的区别？
> - DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。
> - TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
> - 当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小。
> - DELETE操作不会减少表或索引所占用的空间。
> - drop语句将表所占用的空间全释放掉。
> - 一般而言，drop > truncate > delete
##### 平时你们是怎么监控数据库的? 慢SQL是怎么排查的？
> 监控日志，慢查询的SQL可以
>
> 分析MySQL语句查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的SQL语句查询称为“[慢查询](https://www.cnblogs.com/liulei-LL/p/8086397.html)”。
>
> [慢查询优化](https://blog.csdn.net/qq_35571554/article/details/82800463)
##### 你们数据库是否支持emoji表情，如果不支持，如何操作?
> mysql数据库的默认字符集utf8，只能存储3个字节的数据。标准的emoji表情是4个字节，在APP端输入保存表情是用户的普遍需求和行为。
如果不支持可以更换字符集utf8-->utf8mb4 
##### 你们的数据库单表数据量是多少？一般多大的时候开始出现查询性能急剧下降？
> 
##### 查询死掉了，想要找出执行的查询进程用什么命令？找出来之后一般你会干嘛？
> 
##### 读写分离是怎么做的？你认为中间件会怎么来操作？这样操作跟事务有什么关系？
> 
##### 分库分表有没有做过？线上的迁移过程是怎么样的？如何确定数据是正确的？
> [不懂什么是在线数据迁移(一）？看完这篇文章分分钟技能get](http://blog.sina.com.cn/s/blog_15fcda1ec0102wdku.html)
- [手把手项目实战 · 微服务架构下的数据库分库分表实践](https://gitbook.cn/books/5ab8a5ca6fa0783769f10ac1/index.html?utm_source=dl18041001)
> 分库分表
> 在线数据迁移：指的是将正在提供线上服务的数据，从一个地方迁移到另一个地方，而且在整个迁移的过程中要求不停机，服务不受影响。
> 在线迁移步骤：
    - 在线双写，即同时写入新旧两种数据；
    - 历史数据离线搬迁，即离线将历史存量数据从旧系统搬到新系统；
    - 切读，即将读请求路由到新系统；
    - 
### JVM
##### 你知道哪些或者你们线上使用什么GC策略? 它有什么优势，适用于什么场景？
Serial收集器 一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。 特点：CPU利用率最高，停顿时间即用户等待时间比较长。 适用场景：小型应用 通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。

Parallel收集器 采用多线程来通过扫描并压缩堆 特点：停顿时间短，回收效率高，对吞吐量要求高。 适用场景：大型应用，科学计算，大规模数据采集等。 通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。

CMS收集器 采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。 （1）初始标记 （2）并发标记 （3）并发预处理 （4）重新标记 （5）并发清除 （6）并发重置 特点：响应时间优先，减少垃圾收集停顿时间 适应场景：服务器、电信领域等。 通过JVM参数 -XX:+UseConcMarkSweepGC设置

G1收集器 在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。 特点：支持很大的堆，高吞吐量 –支持多CPU和垃圾回收线程 –在主线程暂停的情况下，使用并行收集 –在主线程运行的情况下，使用并发收集 实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收 通过JVM参数 –XX:+UseG1GC 使用G1垃圾回收器

GC的选择
官方推荐，需要根据应用的实际情况进行选择。在选择之前必须要对应用的堆大小、收集频率进行估算。

使用SerialGC的场景： 
1、如果应用的堆大小在100MB以内。 
2、如果应用在一个单核单线程的服务器上面，并且对应用暂停的时间无需求。 
使用ParallelGC的场景: 
如果需要应用在高峰期有较好的性能，但是对应用停顿时间无高要求（比如：停顿1s甚至更长）。 
使用G1、CMS场景: 
1、对应用的延迟有很高的要求。 
2、如果内存大于6G请使用G1。
##### JAVA类加载器包括几种？它们之间的父子关系是怎么样的？双亲委派机制是什什么意思？有什么好处？
> 四种，BootStartClassLoader，ExtClassLoader，AppClassLoader，自定义类加载器。
> 双亲委派机制：保证了类加载的安全性，同样限定名的类只能由同一个类加载加载。
##### 如何自定义一个类加载器？你使用过哪些或者你在什么场景下需要一个自定义的类加载器吗？
> SpringBoot 中的热加载使用的是自定义类加载器
> CGLIB动态代理使用自定义的类加载器来修改class文件并加载
> 
##### 堆内存设置的参数是什么？
> - -Xmn：新生代容量，所以老年代容量 = 堆容量 - 新生代容量
> - -Xms：堆容量初始值
> - -Xmx：堆容量最大值
> - -XX:SurvivorRatio：Eden区与Survivor区的大小比值
> - -XX:MaxTenuringThreshold：设置对象进入老年代的经历的Minor GC次数
> - -XX:PretenureSizeThreshold：设置大于设定值的对象直接放到老年代
> - -XX:CMSInitiatingOccupancyFraction=80:老年代使用80％后开始CMS收集
##### Perm Space中保存什么数据? 会引起OutOfMemory吗？
Perm Space是永久代，也叫方法区，主要包括类信息（Class对象）、常量、静态变量、JIT编译内容；空间不足时也会触发OOM

##### 做gc时，一个对象在内存各个Space中被移动的顺序是什么？
一开始对象在新生代，Young GC一定次数之后就会迁移到年老代
##### 你有没有遇到过OutOfMemory问题？你是怎么来处理这个问题的？处理过程中有哪些收获？
遇到过，通过Eclipse mat分析工具来分析堆转储文件dump，
##### 1.8之后Perm Space有哪些变动? MetaSpace大小默认是无限的么? 还是你们会通过什么方式来指定大小?
取缔了方法区，新增了元空间，元空间使用JVM外部内存，默认是无限的，只收到物理内存的限制，但是可以通过-XX:MetaspaceSize设置来指定初始大小，通过-XX:MaxMetaspaceSize来设置最大容量
##### Jstack是干什什么的? Jstat呢? 如果线上程序周期性地出现卡顿，你怀疑可能是gc导致的，你会怎么来排查这个问题？线程日志一般你会看其中的什么部分？
> Jstack是Java堆栈跟踪工具, 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。
> Jstat是监视JVM进程的工具,用于监控基于HotSpot的JVM，对其堆的使用情况进行实时的命令行的统计，使用jstat我们可以对指定的JVM做如下监控：类的加载及卸载情况，查看新生代、老生代及metaSpace的容量及使用情况，查看新生代、老生代及metaSpace的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间，查看新生代中Eden区及Survior区中容量及分配情况等。
> jstat监控GC情况，监控堆的GC情况，因为只有堆的full GC会导致停顿，获取方法区（也会导致停顿），然后利用jmap导出堆快照，进行分析


> jstat  -gc -h5  -t 26316 1s 20
> -gc 选项：查看JVM堆中垃圾收集情况
> -h5 每隔5行显示一下表头 
> -t 显示从虚拟机启动在当前时间的时间间隔 单位：秒 
> 26536 线程id 
> 1s 1秒显示一次 
> 20 总共显示20次　
##### StackOverFlow异常有没有遇到过？一般你猜测会在什么情况下被触发？如何指定一个线程的堆栈大小？一般你们写多少？
> 遇到过。一般无限递归的时候会触发。线程构造函数中可以传入大小，需要注意的是，该值对JVM而言只是一个建议，JVM有权选择更合适的值，默认1024K。