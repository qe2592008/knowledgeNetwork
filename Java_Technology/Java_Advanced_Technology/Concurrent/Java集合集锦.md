# Java集合集锦

首先来一张集合大家族：
![Java集合](../../../Images/Java集合.png)
## List
### ArrayList
- 非线程安全
- 基于数组实现，增删元素费时，查找省时，拥有快速随机访问能力
- 默认初始容量为10，可以指定初始容量，容量不足时需要扩容，默认扩容为原容量的1.5倍
- 支持序列化、克隆(浅拷贝)、排序功能
- 支持fail-fast
### LinkedList
- 非线程安全
- 基于链表实现，采用双向链表实现，增删元素省时，查找元素费时，涉及遍历的操作均费时
- 天然无限容量
- 支持序列化、克隆（浅拷贝）
- 它也可以被当作堆栈、队列或双端队列进行操作
- 支持fail-fast
### Vector
- 线程安全，内部采用synchronized实现线程安全
- 基于数组实现，增删元素费时，查找省时，拥有快速随机访问能力
- 默认初始容量为10，可以指定初始容量和增量，容量不足时需要扩容，每次扩容增量为设置的增量，如果未设置，默认扩容为原容量的2倍，
- 支持序列化、克隆(浅拷贝)、排序功能
- 支持fail-fast
### CopyOnWriteArrayList
- 线程安全
- 基于写时复制COW实现，修改集合时（写操作）将集合底层数组拷贝一份，在新数组中操作（需要加Lock锁，避免多线程操作时复制出N多的新数组），完成后将指针指向新数组，以分离读写操作，因为读取的时候并不需要复制。
- 基于数组实现，每次添加N个元素时都会新增数组，新数组会比原数组容量大N，从而实现扩容，即每次新增都会涉及扩容操作，所以需要尽量减少写操作
- 多用于读多写少的场景
- 支持序列化、排序、克隆
## Set
### HashSet
- 非线程安全
- 无序的集合，无重复元素，可存在一个null值
- 底层基于HashMap实现，其实就是以HashMap的键来表示，值为固定的PRESENT
- 可以指定初始容量，默认为16
- 可以指定负载因子，默认为0.75
- 基于HashMap的扩容原则进行扩容
- 支持序列化、克隆
- 支持fail-fast
### TreeSet
- 非线程安全
- 有序集合，
- 底层基于TreeMap实现，其实就是以TreeMap的键来表示，值为固定的PRESENT
- 支持序列化、克隆、排序
- 支持fail-fast
### LinkedHashSet

### CopyOnWriteArraySet

### ConcurrentSkipListSet

## Map
### HashMap
- 非线程安全
- 元素无序
- 支持null键和null值，其中null键只能有一个，null值不做限制
- 可以指定初始容量，默认是16，如果指定了容量，那么程序会计算一个大于等于给定容量的最小的2的次幂值作为桶数组的实际容量
- 可以指定负载因子，默认为0.75，一般不指定，这个0.75是空间和时间
- 基于哈希算法实现，采用链地址法解决哈希冲突
- 扩容将容量增加一倍
- 支持序列化、克隆
- 支持fail-fast
#### JDK1.7
- 底层基于数组+链表实现，数组用于存放链表头节点，链表用于处理Hash冲突
- 链表采用头插法，会导致在扩容时形成循环链表
- 扩容后迁移元素时，元素全部重新hash，重新落位
#### JDK1.8
- 底层基于数组+链表+红黑树实现，数组用于存放链表头节点或者树根节点，链表和红黑树用于处理hash冲突
- 链表采用尾插法，避免循环链表
- 优先采用链表解决Hash冲突，当链表元素达到8个而且桶数组容量达到64以上，则将链表转换为红黑树，如果桶数组容量不足64，则优先进行扩容
- 扩容后迁移元素时，元素迁移分链表和红黑树两种情况，两种情况都会对原结构数据进行分拆，拆成两个小链表或者小红黑树保存到新数组的对应位置，而不是全部重新hash，其中一个小结构会落位于原位置，另一个落位于原位置+旧容量的位置，有一点要注意就是，红黑树分拆的小树如果容量小于6个元素，需要退化为链表。
### TreeMap
- 非线程安全
- 有序的Map集合，基于Comparable或者Comparator，这个基于使用哪个构造器
- 基于红黑树实现
- 
- 支持克隆、排序、序列化
- 支持fail-fast
### LinkedHashMap

### HashTable
- 线程安全
- 不支持null键和null值
### ConcurrentHashMap

### ConcurrentSkipLinkMap

## Queue

## Deque
