# Java集合集锦

首先来一张集合大家族：
![Java集合](../../../Images/Java集合.png)
## List
### ArrayList
- 非线程安全
- 基于数组实现，增删元素费时，查找省时，拥有快速随机访问能力
- 默认初始容量为10，可以指定初始容量，容量不足时需要扩容，默认扩容为原容量的1.5倍
- 支持序列化、克隆(浅拷贝)、排序功能
- 支持fail-fast
### LinkedList
- 非线程安全
- 基于链表实现，采用双向链表实现，增删元素省时，查找元素费时，涉及遍历的操作均费时
- 天然无限容量
- 支持序列化、克隆（浅拷贝）
- 它也可以被当作堆栈、队列或双端队列进行操作
- 支持fail-fast
### Vector
- 线程安全，内部采用synchronized实现线程安全
- 基于数组实现，增删元素费时，查找省时，拥有快速随机访问能力
- 默认初始容量为10，可以指定初始容量和增量，容量不足时需要扩容，每次扩容增量为设置的增量，如果未设置，默认扩容为原容量的2倍，
- 支持序列化、克隆(浅拷贝)、排序功能
- 支持fail-fast
### CopyOnWriteArrayList
- 线程安全
- 基于写时复制COW实现，修改集合时（写操作）将集合底层数组拷贝一份，在新数组中操作（需要加Lock锁，避免多线程操作时复制出N多的新数组），完成后将指针指向新数组，以分离读写操作，因为读取的时候并不需要复制。
- 基于数组实现，每次添加N个元素时都会新增数组，新数组会比原数组容量大N，从而实现扩容，即每次新增都会涉及扩容操作，所以需要尽量减少写操作
- 多用于读多写少的场景
- 支持序列化、排序、克隆
## Set
### HashSet
- 非线程安全
- 无序的集合，无重复元素，可存在一个null值
- 底层基于HashMap实现，其实就是以HashMap的键来表示，值为固定的PRESENT
- 可以指定初始容量，默认为16
- 可以指定负载因子，默认为0.75
- 基于HashMap的扩容原则进行扩容
- 支持序列化、克隆
- 支持fail-fast
### TreeSet
- 非线程安全
- 有序Set集合，基于Comparable或者Comparator实现排序，而这个又基于使用哪个构造器来创建集合实例
- 底层基于TreeMap实现，其实就是以TreeMap的键来表示，值为固定的PRESENT
- 支持序列化、克隆、排序
- 支持fail-fast
- 其余与TreeMap一致
### LinkedHashSet
- 非线程安全
- 有序Set集合，只支持插入顺序排序
- 底层基于LinkedHashMap和HashSet实现，几乎所有操作全部基于HashSet的对应方法，而链表方面的实现则全部基于LinkedHashMap
- 支持序列化、克隆、排序
- 支持fail-fast
### CopyOnWriteArraySet
- 线程安全
- 基于数组实现的无序的Set集合，虽然底层是数组，但仍然不支持出现重复元素
- 底层完全基于CopyOnWriteArrayList实现，所有的方法都是通过调用CopyOnWriteArrayList的对应方法来实现。
### ConcurrentSkipListSet
- 线程安全
- 基于跳表实现的有序的Set
- 底层完全依赖ConcurrentSkipListMap来实现，所有的方法基本都是通过调用ConcurrentSkipListMap的对应方法来实现的
- 支持序列化、克隆、排序
## Map
### HashMap
- 非线程安全
- 元素无序
- 支持null键和null值，其中null键只能有一个，null值不做限制
- 可以指定初始容量，默认是16，如果指定了容量，那么程序会计算一个大于等于给定容量的最小的2的次幂值作为桶数组的实际容量
- 可以指定负载因子，默认为0.75，一般不指定，这个0.75是在时间和空间成本上寻求一种折衷
- 基于哈希算法实现，采用链地址法解决哈希冲突
- 扩容将容量增加一倍
- 支持序列化、克隆
- 支持fail-fast
#### JDK1.7
- 底层基于数组+链表实现，数组用于存放链表头节点，链表用于处理Hash冲突
- 链表采用头插法，会导致在扩容时形成循环链表，形成原因是两个线程同时进行扩容操作后迁移数据的时候，循环中的`Entry<K,V> next = e.next;`一句，它会提前将e节点的下级节点预存起来，如果一个线程在执行完此句后中断，另一个线程完成了迁移操作，而迁移数据采用的仍然是头插法，就会导致节点的顺序颠倒过来（next颠倒），那么该线程再次开始执行时，由于next已被预存（保留的是原始的next,现在已被另一个线程修改），导致两个节点被各自的next互相引用形成循环链表
- 扩容后迁移元素时，元素全部重新hash，重新落位
- 可能会导致插入的数据丢失
- [HashMap的hashSeed的问题](https://blog.csdn.net/qq_30447037/article/details/78985216)
#### JDK1.8
- 底层基于数组+链表+红黑树实现，数组用于存放链表头节点或者树根节点，链表和红黑树用于处理hash冲突
- 链表采用尾插法，避免循环链表
- 优先采用链表解决Hash冲突，当链表元素达到8个而且桶数组容量达到64以上，则将链表转换为红黑树，如果桶数组容量不足64，则优先进行扩容
- 扩容后迁移元素时，元素迁移分链表和红黑树两种情况，两种情况都会对原结构数据进行分拆，拆成两个小链表或者小红黑树保存到新数组的对应位置，而不是全部重新hash，其中一个小结构会落位于原位置，另一个落位于原位置+旧容量的位置，有一点要注意就是，红黑树分拆的小树如果容量小于6个元素，需要退化为链表。
### TreeMap
- 非线程安全
- 有序的Map集合，基于Comparable或者Comparator实现排序，而这个又基于使用哪个构造器来创建集合实例
- 基于红黑树实现，获取和添加的操作时间复杂度均为O(logn)
- 红黑树的操作主要包括：添加元素、添加修复、删除元素、删除修复、获取元素、左旋操作、右旋操作、着色操作
- 采用中序遍历排序和遍历：先左再根后右
- 支持克隆、排序、序列化
- 支持fail-fast
### LinkedHashMap
- 非线程安全
- 有序的Map集合，基于accessOrder的值来决定排序方式，true表示访问顺序（get的顺序），false表示插入顺序（put的顺序）
- 底层基于双向链表和HashMap实现，就是对HashMap中的元素又附着一层链表来表示元素的顺序。
- 该类中主要涉及的就是有关新增的链表的操作，凡是涉及map的操作一律调用HashMap中的方法来完成，拥有HashMap的所有功能
- 支持fail-fast
### WeakHashMap
- 非线程安全
- 基于hash算法实现的Map集合，使用链地址法解决hash冲突，
- 基于数组+链表方式存储数据
- 可以指定初始容量和负载因子，初始容量默认为16，负载因子默认为0.75
- 扩容默认增加一倍容量，迁移元素时需要全部重新hash进行落位
- 与HashMap不同之处在于这里使用弱键，弱引用对象将在下次GC时被回收掉（前提是没有强引用指向它）
- 弱键是通过WeakReference和ReferenceQueue实现的，使用WeakReference来定义弱键，使用ReferenceQueue来存放被GC回收的弱键，然后在需要（扩容）时根据队列将集合中对应的元素删除。
- 支持fail-fast
### HashTable
- 线程安全，几乎所有操作都通过同步原语synchronized来实现线程安全
- 不支持null键和null值
- 基于hash算法，使用链地址法解决hash冲突
- 无序的Map集合，类似于HashMap，同样以数组+链表方式存储数据
- 可自定义初始容量和负载因子，初始容量默认为11，负载因子默认0.75，如果自定义初始容量为0则默认置为1
- 当元素数量达到阈值则进行扩容，新容量为原来的2倍+1
- 支持序列化、克隆
- 支持fail-fast
### ConcurrentHashMap
- 线程安全
- 底层使用无限循环+CAS操作来保证多线程安全
- 可以指定初始容量和负载因子，初始化容量默认为16，负载因子默认为0.75
- 并发等级DEFAULT_CONCURRENCY_LEVEL是可以自定义的,默认为16，它代表的就是可以同时支持的并发量
- 扩容后迁移数据时需要拆分原结构（链表或者红黑树）将原结构中的数据分拆成两个子结构，分别位于新数组的原位置和原位置+旧容量的位置（即新数组的低位区和高位区）
- 支持序列化功能
#### JDK1.7
- 底层采用Segment数组+table数组来实现
- 分段数组的最大数量为1<<16个
- 分段数组的容量最小为2，可以扩容，扩容为原来的2倍，容量必须为2的次幂
- 扩容针对的是table数组，Segment数组一经初始化就固定不变了，这样扩容不会导致整个集合全部扩容，而是仅仅一个Segment数组的元素代表的table数组进行扩容和数据迁移
- 链表采用头插法实现，扩容迁移数据时也是头插法
#### JDK1.8
- 放弃分段锁方式，恢复原始的数组+链表+红黑树方式实现
- 链表元素达到8个且桶数组容量达到64以上，则将单向链表转化为一个红黑树，其实它同时还是一个双向链表，双向链表的目的是为了退化为链表做的准备
- 数据迁移时，红黑树需进行分拆，如果小树容量低于6个则退化为单向链表
- 针对桶位节点加锁的方式来保证线程安全
- 当多线程并发进行扩容数据迁移时，需要为每个线程分配迁移区间，区间大小默认为16个数组位（分区步长）
- 重点变量：
    - sizeCtr
        - 0：default，默认值，在使用无参构造器构造实例时
        - -1：初始化桶数组
        - ((rs << RESIZE_STAMP_SHIFT)+2) +N：数组扩容，代表线程数量，但有个基数(rs << RESIZE_STAMP_SHIFT）+2，在此基数上进行增减，每有一个线程参加扩容，该值+1，否则减1，扩容结束会恢复基数值
        - 0.75*table.length：正常状态，代表扩容阈值
    - hash
        - -1：（MOVED）表示正在扩容，且当前桶位的元素已迁移完毕
        - -2：（TREEBIN）表示红黑树
- 问题：如果在递归中使用computeIfAbsent方法那么就会导致内存100%
### [ConcurrentSkipLinkMap](https://blog.csdn.net/qq_35326718/article/details/78870658)
- 线程安全，键和值不能为null
- 基于跳表实现的Map
- 有序的Map实现，基于Comparable或者Comparator实现排序
- 基于无限循环+CAS实现无锁操作来保证并发操作的安全性
- 支持序列化、克隆、排序
## Queue
### PriorityQueue

### ConcurrentLinkedQueue

### BlockingQueue
#### DelayQueue

#### PriorityBlockingQueue

#### SynchronousQueue

#### ArrayBlockingQueue

#### LinkedBlockingQueue

#### LinkdTreansferQueue

## Deque
### ArrayDeque

### LinkedList

### ConcurrentLinkedDeque

### LinkedBlockingDeque
