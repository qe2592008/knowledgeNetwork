# 23种设计模式
![23种设计模式](../../../Images/23种设计模式.jpg)
## 设计模式
- 创建型模式
    - **工厂模式**：使用工厂接口统筹所有工厂类，避免修改原有工厂类，针对的是一个目标类
    - 抽象工厂模式：针对的是一系列目标类，这一系列属于同一个工厂
    - **单例模式**：通过编程实现只有一个实例，多种实现方式：懒汉-饿汉-静态内部类-枚举-双重校验
    - 建造者模式：创建对象的一种方式
    - 原型模式：将对象作为一个原型，然后进行克隆、复制等操作，产生一个和原对象类似的新对象
- 结构型模式
    - **适配器模式**：问题规模是两个接口中的方法不匹配，可以通过调用的方式实现，但是调用的实现有两种，一种是通过继承来实现，一种是通过组合来实现，一般情况我们是使用组合实现的，新增一个适配器类，在其中包含目标接口的实现类成员，使用成员实例调用其目标方法。
        - 类的适配器模式：通过继承来实现适配
        - 对象的适配器模式：通过组合来实现适配
        - 接口的适配器模式：通过抽象类来实现适配，不同于上面两种，它目的是为了屏蔽接口中不需要的多余方法，只实现自己相关的方法
    - 装饰模式：为目标类的方法增加新功能、新内容，为了避免修改目标类，创建一个装饰类，与目标类实现同一接口，并持有目标类的实例，然后就能重写目标方法，并在其中通过目标类的成员调用目标类的同名方法，来完成方法增强。貌似有点代理的意味
    - **代理模式**：创建实现同一个接口的代理类，在代理类中创建目标类并进行访问控制，代理类全权代理目标类，目标完全在其庇护之下，不对外。
    - **外观模式**：为了屏蔽子系统的复杂性，提供一个公共的外观类来一致对外提供服务，这个外观类整合整个系统的各个子功能，直接对外提供整体服务，避免了客户直接调用子系统的复杂性。
    - 桥接模式：涉及到双方，用一个桥连接来进行解耦，各自进行扩展，互不影响。连接的双方要自由扩展，必然是有抽象层的，或接口，或抽象类，一般是接口。
    - 组合模式：针对特定的树形接口而设的模式
    - 享元模式：用以实现共享池，一般与工厂模式配合使用，工厂用于管理池（包括创建对象、删除对象等），池的实现就是一个总接口用于定义池中项目的总功能，再来一些实现类用于实现具体的功能，工厂发现池中对象不足时就会自动创建对应的实现类的对象，多出来就是删除多余的对象。管理功能全部靠工厂类来完成。这里有一个总接口的目的其实是为了内部解耦，容易扩展，表示目标项目可以有多种选择，择一而用即可。
- 行为型模式
    - **策略模式**：在设计一个功能算法总接口，然后提供多个算法的实现类，就是这么个简单的模式，使用哪个实现类，决定权调用方。
    - **模板模式**：模板模式其实就是利用抽象类的抽象方法或者空方法（protected修饰）来将主功能的部分子功能的实现下放到实现类中完成，可能有多种实现方式，不同的实现类实现方式不同，调用方调用抽象类的主方法来实现整体的功能，子功能的地就由实现类来完成。
    - **观察者模式**：
    - 迭代器模式
    - 责任链模式
    - 命令模式
    - 备忘录模式
    - 状态模式
    - 访问者模式
    - 中介者模式
    - 解释器模式
## 工厂模式
在使用简单工厂模式时，是直接针对目标类创建工厂类来进行代理生产实例，一旦新增目标类，就需要修改工厂类，违背开闭原则

这里创建一个工厂接口，来统筹管理工厂类，新增目标类，新增一个工厂类即可，避免修改原有工厂类。

## 装饰模式与代理模式区别：
二者几乎完全一致的实现方式，令人混淆，其实还是有一点区别的额，装饰模式重在增强，代理模式重在控制。

装饰模式中，装饰器类持有的目标类的实例的获取方式是传入的，表示目标对象也是被正常使用中的

代理模式中，代理类持有的目标类的实例的获取方式是自己创建的（new），表示目标对象完全在代理类的掌控之中，不会在别的地方使用。

## 桥接模式

将抽象和实现进行解耦，抽象指的是拥有扩展能力的一方，该方应该有一个公共接口，然后有若干实现类，并可以随时新增实现类来进行扩展，另一方即使实现，指的是实际的使用者，或者调用方。

这样使用者想要调用抽象的一方，其实可以直接在使用者类里面直接持有抽象接口来引用某个具体的抽象是实现类对象的，但是这样的话，调用方和被调用方强耦合，为了解耦，将这一部分抽取出来建立桥抽象类，然后调用者统一调用桥的实现类的对象中的方法来间接调用抽象方的内容。

这里将抽象方整体作为一个组件，如果直接持有调用，那么就是强耦合，虽然在抽象方内部来看，具体的抽象实现类和抽象接口之间解耦合的，但这只是组织内部的小耦合，组件与组件之间的耦合才是这里关注的重点。

## 组合模式

在树形结构中，分为容器构件和叶子构件，容器包含容器或叶子，叶子是最终节点，不包含任何内容（或解释成目录和文件），显然二者的性质不同，那么在处理的时候就需要进行区分，复杂度就很高，采用这种模式主要目的就是去除这种复杂度，将二者包装成一致的构件，从而可以一致对待，降低了时限复杂度。至于包装方式，我们可以设计一个包含容器和叶子节点所有功能的总接口，然后进行实现，其不支持的功能，则可以抛异常处理或者做出提示，只完成支持的功能。但是对外而言，二者就拥有了相同的方法，虽然部分不支持，但内部也做了处理（异常）。

