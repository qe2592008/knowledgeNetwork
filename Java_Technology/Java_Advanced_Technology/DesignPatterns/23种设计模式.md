# 23种设计模式
![23种设计模式](../../../Images/23种设计模式.jpg)
## 设计模式
- 创建型模式
    - **工厂模式**：使用工厂接口统筹所有工厂类，避免修改原有工厂类，针对的是一个目标类
    - 抽象工厂模式：针对的是一系列目标类，这一系列属于同一个工厂
    - **单例模式**：通过编程实现只有一个实例，多种实现方式：懒汉-饿汉-静态内部类-枚举-双重校验
    - 建造者模式：创建对象的一种方式，将个一个模块分割成多个小模块，独自构建，最后在整合起来成为一整体。
    - 原型模式：将对象作为一个原型，然后进行克隆、复制等操作，产生一个和原对象类似的新对象
- 结构型模式
    - **适配器模式**：问题规模是两个接口中的方法不匹配，可以通过调用的方式实现，但是调用的实现有两种，一种是通过继承来实现，一种是通过组合来实现，一般情况我们是使用组合实现的，新增一个适配器类，在其中包含目标接口的实现类成员，使用成员实例调用其目标方法。
        - 类的适配器模式：通过继承来实现适配
        - 对象的适配器模式：通过组合来实现适配
        - 接口的适配器模式：通过抽象类来实现适配，不同于上面两种，它目的是为了屏蔽接口中不需要的多余方法，只实现自己相关的方法
    - 装饰模式：为目标类的方法增加新功能、新内容，为了避免修改目标类，创建一个装饰类，与目标类实现同一接口，并持有目标类的实例，然后就能重写目标方法，并在其中通过目标类的成员调用目标类的同名方法，来完成方法增强。貌似有点代理的意味
    - **代理模式**：创建实现同一个接口的代理类，在代理类中创建目标类并进行访问控制，代理类全权代理目标类，目标完全在其庇护之下，不对外。
    - **外观模式**：为了屏蔽子系统的复杂性，提供一个公共的外观类来一致对外提供服务，这个外观类整合整个系统的各个子功能，直接对外提供整体服务，避免了客户直接调用子系统的复杂性。
    - 桥接模式：涉及到双方，用一个桥连接来进行解耦，各自进行扩展，互不影响。连接的双方要自由扩展，必然是有抽象层的，或接口，或抽象类，一般是接口。
    - 组合模式：针对特定的树形接口而设的模式
    - 享元模式：用以实现共享池，一般与工厂模式配合使用，工厂用于管理池（包括创建对象、删除对象等），池的实现就是一个总接口用于定义池中项目的总功能，再来一些实现类用于实现具体的功能，工厂发现池中对象不足时就会自动创建对应的实现类的对象，多出来就是删除多余的对象。管理功能全部靠工厂类来完成。这里有一个总接口的目的其实是为了内部解耦，容易扩展，表示目标项目可以有多种选择，择一而用即可。
- 行为型模式
    - **策略模式**：在设计一个功能算法总接口，然后提供多个算法的实现类，就是这么个简单的模式，使用哪个实现类，决定权调用方。
    - **模板模式**：模板模式其实就是利用抽象类的抽象方法或者空方法（protected修饰）来将主功能的部分子功能的实现下放到实现类中完成，可能有多种实现方式，不同的实现类实现方式不同，调用方调用抽象类的主方法来实现整体的功能，子功能的地就由实现类来完成。
    - **观察者模式**：
    - 迭代器模式
    - 责任链模式
    - 命令模式
    - 备忘录模式
    - 状态模式
    - 访问者模式
    - 中介者模式
    - 解释器模式
## 工厂模式
在使用简单工厂模式时，是直接针对目标类创建工厂类来进行代理生产实例，一旦新增目标类，就需要修改工厂类，违背开闭原则

这里创建一个工厂接口，来统筹管理工厂类，新增目标类，新增一个工厂类即可，避免修改原有工厂类。

不使用工厂模式的情况：一个产品接口，多个产品实现类，针对产品接口来创建工厂类。当新增产品实现类的时候，需要修改这个工厂类，违背开闭原则。
使用工厂模式的情况：在上面产品模块的基础上创建一个工厂接口，然后针对每种产品实现类创建各自的工厂类，新增产品实现类，只要新增一个工厂类即可。
## 抽象工厂模式
工厂模式的升级版，主要用于生产多种目标类的组合（族）。

同样一个工厂接口用于统筹管理工厂类（这个工厂定义了这个产品族中要生产的多个产品种类，具体工厂则是决定当前产品族中的该类产品的具体型号），当新增一个产品族时，可以新增一个工厂类，避免修改原有工厂，在这点上与工厂模式一致（只是产品规模不同），满足开闭原则

但是如果要在产品族中增加一种产品，那么就需要修改所有工厂接口和实现类，这点不满足开闭原则。
## 构建者模式
将一个整个模块分割成几个小模块，这几个模块没有强耦合，可以自由实现，然后使用构建者模式

使用一个构建者接口，然后根据具体情况，进行实现，不同的实现代表不同的组成部件，但是这些部件是属于同一类的部件，最后再来个统筹者将这些子部件结合起来，注意这个统筹者是固定的，也就是说子部件组装方式是固定不变的，变化的只是各个子部件自身的实现方式，子部件之间的关系是不能变化的。
## 适配器模式
类A要调用类B的方法，有两种方式，第一种是继承，让A继承B，那么B的方法自然出现在A中供调用，另一种是组合，在类A中定义成员变量B，将B实例注入进来，这样A中就能通过B实例调用B的方法。这也是适配器实现的两种方式

适配器适用的范围更开泛一些，因为可能涉及到扩展性，所以使用了接口或者抽象类来进行解耦，那么情况就是B是一个接口，B有多个实现类，A是调用者，同样，只要A实现了B或者A中注入B的实例就能实现调用，但是这样一来，A和B就会强耦合在一起，所以使用一个适配器来将二者隔开：

第一种是定义实现了B的适配器抽象类，那么适配器类中就有了B的方法，调用者A继承适配器类实现调用
另一种是定义适配器抽象类，持有B的实例，然后调用者A继承适配器来实现调用
这种方式同样便于调用方的扩展，比如调用方也定义一个抽象类，然后实现多个具体调用者类，那么只要这个抽象类继承自上面的适配器抽象类就能实现双方的自由扩展

以上描述不正确

## 装饰模式与代理模式区别：
二者几乎完全一致的实现方式，令人混淆，其实还是有一点区别的额，装饰模式重在增强，代理模式重在控制。

装饰模式中，装饰器类持有的目标类的实例的获取方式是传入的，表示目标对象也是被正常使用中的

代理模式中，代理类持有的目标类的实例的获取方式是自己创建的（new），表示目标对象完全在代理类的掌控之中，不会在别的地方使用。

## 桥接模式

将抽象和实现进行解耦，抽象指的是拥有扩展能力的一方，该方应该有一个公共接口，然后有若干实现类，并可以随时新增实现类来进行扩展，另一方即使实现，指的是实际的使用者，或者调用方。

这样使用者想要调用抽象的一方，其实可以直接在使用者类里面直接持有抽象接口来引用某个具体的抽象是实现类对象的，但是这样的话，调用方和被调用方强耦合，为了解耦，将这一部分抽取出来建立桥抽象类，然后调用者统一调用桥的实现类的对象中的方法来间接调用抽象方的内容。

这里将抽象方整体作为一个组件，如果直接持有调用，那么就是强耦合，虽然在抽象方内部来看，具体的抽象实现类和抽象接口之间解耦合的，但这只是组织内部的小耦合，组件与组件之间的耦合才是这里关注的重点。

## 组合模式

在树形结构中，分为容器构件和叶子构件，容器包含容器或叶子，叶子是最终节点，不包含任何内容（或解释成目录和文件），显然二者的性质不同，那么在处理的时候就需要进行区分，复杂度就很高，采用这种模式主要目的就是去除这种复杂度，将二者包装成一致的构件，从而可以一致对待，降低了时限复杂度。至于包装方式，我们可以设计一个包含容器和叶子节点所有功能的总接口，然后进行实现，其不支持的功能，则可以抛异常处理或者做出提示，只完成支持的功能。但是对外而言，二者就拥有了相同的方法，虽然部分不支持，但内部也做了处理（异常）。

