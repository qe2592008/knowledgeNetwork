# 单例的七种写法

## 懒汉——线程不安全
```java
class SingletonOne {
    public static SingletonOne singleton;
    private SingletonOne() {}
    public static SingletonOne getSingleton() {
        if (singleton == null)
            return new SingletonOne();
        return singleton;
    }
}
```
> 实现了懒加载，但线程不安全

## 懒汉——线程安全
```java
class SingletonTwo {
    public static SingletonTwo singleton;
    private SingletonTwo() {}
    public static synchronized SingletonTwo getSingleton() {
        if (singleton == null)
            return new SingletonTwo();
        return singleton;
    }
}
```
> 在第一种的基础上加了个synchronized，线程安全了，同时实现了懒加载，只是效率不高
## 饿汉
```java
class SingletonThree {
    public static SingletonThree singleton = new SingletonThree();
    private SingletonThree () { }
    public static SingletonThree getSingleton() {
        return singleton;
    }
}
```
> 由于实例优先提供，不存在线程安全问题，但是没有实现懒加载

## 饿汉——变种
```java
class SingletonFour {
    public static SingletonFour singleton;
    static {
        singleton = new SingletonFour();
    }
    private SingletonFour () { }
    public static SingletonFour getSingleton() {
        return singleton;
    }
}
```
> 其实和之前的一样

## 静态内部类
```java
class SingletonFive {
    private static class SingletonHolder {
        private static SingletonFive singleton = new SingletonFive();
    }
    private SingletonFive () {}
    public static final SingletonFive getSingleton(){
        return SingletonHolder.singleton;
    }
}
```
> 静态内部类保证了懒加载，优先提供保证了线程安全
## 枚举
```java
enum SingletonSix {
    SINGLETON;
    public void whateverMethod() {

    }
}
```
> 枚举的天然特性保证了单例，天然的私有构造器，天然的线程安全性

## 双重校验锁
```java
class SingletonSeven {
    private static volatile SingletonSeven singleton;
    private SingletonSeven() {}
    public static SingletonSeven getSingleton(){
        if (singleton == null) {
            synchronized (SingletonSeven.class) {
                if (singleton == null)
                    return new SingletonSeven();

            }
        }
        return singleton;
    }
}
```
> 注意点一是volatile的使用，为了防止暴露一个未初始化的不完整单例实例；注意点二就是双重判空校验，第一个判断避免了频繁的加锁，第二个判断可以拦住多余的创建实例的线程，注意点三就是加锁，保证了线程安全（只有一个实例）