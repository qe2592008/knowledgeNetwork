# HashMap与ConcurrentHashMap解析
## HashMap(java1.7)
- 结构：数组+单向链表
- 节点：key（键）、value（值）、hash（key的hash值，不仅仅是key的hashCode，还需要经过复杂运算）、next（指向链表下一节点）
- 重点属性：
    - capacity：当前集合容量，默认的初始容量为16，需要确保为2的n次方，可扩容，扩容为2倍，如果指定初始容量，那么需要在初始化的时候计算出合适的初始容量，这个值为大于等于给定容量值的最小的2的次幂值
    - loadFactor：负载因子，默认0.75f
    - threshold：扩容阈值，当集合元素数量达到该阈值，则尝试扩容
- 初始化：集合数组的初始化采用***懒初始化***模式，在首次添加元素的时候才会执行，需要确定capacity、threshold等值
- hash方法：
- put操作：先通过key的hash值定位到数组位，然后在链表中找是否存在相同的key，若存在则替换值，否则头插法新增节点
- get操作：先通过key的hash值定位到数组位，然后在遍历链表查找是否存在相同的key，存在则返回对应的值，否则返回null
- 扩容操作：扩容的触发在put操作中，put新元素时先进行扩容校验，然后在执行新增操作。具体的扩容条件为：容量达到阈值并且要添加的数组位置存在元素，则执行扩容，将容量扩容为2倍，需要重新计算扩容阈值threshold；扩容后元素的迁移是分拆迁移，将原位的链表分拆为两个小链表分别放到新数组的原位（低位区）与原位+旧容量位（高位区）
- 问题：
    1. 头插法可能会导致循环链表
    2. 可能会存在插入的数据丢失
## ConcurrentHashMap(java1.7)
- 结构：数组+分段数组+链表
- 节点：key（键）、value（值）、hash（key的hash值）、next（指向链表下一节点）
- 重点属性：
    - initialCapacity：初始容量为16，这个表示的是集合总容量，我们关注的是每个分段数组的容量，这个容量可以由该值除以分段数组的个数来计算得到，得到的值将作为一个基准来获得一个大于等于基准的2的次幂值，该值最小为2
    - loadFactor：负载因子，也是针对分段数组而言的，默认为0.75
    - concurrencyLevel：并发级别，默认为16，其实这也就是外层数组的容量，即分段数组的数量，可以指定该值，最后得出的会是一个大于等于该值的最小2的次幂值，该值一旦确定不再改变，扩容不会扩容这个值，扩容的是某个分段数组的容量；该值存在最大值为1<<16
    - segmentShift：移位数
    - segmentMask：掩码
- 初始化（CAS）：部分在构造器中完成初始化操作，部分在添加元素的时候完成，构造器中只会初始化第一个分段数组，添加元素的时候会首先对当前要添加首个元素的分段数组进行初始化(这个也算是懒初始化的模式了)，这里需要借助CAS+while循环保证多个线程并发初始化同一个分段数组的成功
- hash方法：
- put操作（加锁）：先计算hash值，通过移位数和掩码计算分段数组的下标（位于外层数组的哪一位），然后如果是该位分段数组首次添加元素需要先进性初始化，之后进行元素新增；首先获取独占锁（即整个分段数组作为一个锁）然后根据hash值定位到分段数组下标位，然后分无元素和有元素两种情况进行处理，无元素直接添加，有元素则需要遍历链表，或替换值，或头插法添加；在这里需要注意在真正执行添加导致之前会校验容量是否达到阈值，即当前分段数组如果增加一个元素后容量是否达到扩容阈值，如果达到需要先进行扩容，完成后再添加，最后释放独占锁
- get操作（CAS）：首先计算key的hash值，通过移位数和掩码计算分段数组的下标，然后在内部数组中使用hash定位到数组位，循环链表来获取指定key的值，不存在返回null
- 扩容操作（加锁）：扩容也是在获取独占锁的前提下进行的，因为是在put的最后几步才执行，所以不需要自己获取锁，直接使用put操作的锁即可；扩容的条件为当前分段数组内部数组容量+1的情况下达到了当前分段数组的阈值，扩容为双倍扩容，需要重新计算当前分段数组的扩容阈值；至于元素迁移，还是分拆迁移。分拆迁移扩容的实现依靠了两个for循环，简化了分拆流程，分拆其实是将原来的链表先分拆成两个链表，然后将链表头结点元素赋给新数组的对应数组位
- 并发分析：
    - 初始化槽：采用CAS保证并发安全
    - get操作：采用CAS来保证可以访问到新增到链表头的元素
    - put操作：采用加锁保证并发安全
    - 扩容操作：采用加锁保证扩容的并发安全，volatile保证扩容之后新的分段数组的可见性（table被volatile修饰）
    - 移除操作：采用CAS来保证头结点删除的并发安全，volatile保证非头结点删除的可见性（next被volatile修饰）
## HashMap(java1.8)
- 结构：数组+单向链表+红黑树
- 链表节点：key（键）、value（值）、hash（key的hash值）、next（指向链表下一节点）
- 树节点：key（键）、value（值）、hash（key的hash值）、next（指向链表下一节点）、parent（指向父节点）、left（指向左子节点）、right（指向右子节点）、prev（指向）、red（着色）
- 重点属性：
    - 
    - threshold：扩容阈值
    - loadFactor：负载因子，默认为0.75
## ConcurrentHashMap(java1.8)